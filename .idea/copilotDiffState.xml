<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/common/main/kotlin/settingdust/calypsos_mobs/entity/FurnaceSprite.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/common/main/kotlin/settingdust/calypsos_mobs/entity/FurnaceSprite.kt" />
              <option name="originalContent" value="package settingdust.calypsos_mobs.entity&#10;&#10;import net.minecraft.core.particles.ParticleOptions&#10;import net.minecraft.core.particles.ParticleTypes&#10;import net.minecraft.nbt.CompoundTag&#10;import net.minecraft.network.syncher.EntityDataAccessor&#10;import net.minecraft.network.syncher.EntityDataSerializer&#10;import net.minecraft.network.syncher.EntityDataSerializers&#10;import net.minecraft.network.syncher.SynchedEntityData&#10;import net.minecraft.sounds.SoundEvents&#10;import net.minecraft.world.InteractionHand&#10;import net.minecraft.world.InteractionResult&#10;import net.minecraft.world.SimpleContainer&#10;import net.minecraft.world.damagesource.DamageSource&#10;import net.minecraft.world.entity.EntityType&#10;import net.minecraft.world.entity.PathfinderMob&#10;import net.minecraft.world.entity.ai.behavior.BehaviorUtils&#10;import net.minecraft.world.entity.ai.behavior.EntityTracker&#10;import net.minecraft.world.entity.ai.memory.MemoryModuleType&#10;import net.minecraft.world.entity.item.ItemEntity&#10;import net.minecraft.world.entity.npc.InventoryCarrier&#10;import net.minecraft.world.entity.player.Player&#10;import net.minecraft.world.entity.schedule.Activity&#10;import net.minecraft.world.item.ItemStack&#10;import net.minecraft.world.item.crafting.RecipeManager&#10;import net.minecraft.world.item.crafting.RecipeType&#10;import net.minecraft.world.level.Level&#10;import net.minecraft.world.phys.AABB&#10;import net.minecraft.world.phys.Vec3&#10;import net.minecraftforge.common.ForgeHooks&#10;import net.tslat.smartbrainlib.api.SmartBrainOwner&#10;import net.tslat.smartbrainlib.api.core.BrainActivityGroup&#10;import net.tslat.smartbrainlib.api.core.SmartBrainProvider&#10;import net.tslat.smartbrainlib.api.core.behaviour.FirstApplicableBehaviour&#10;import net.tslat.smartbrainlib.api.core.behaviour.OneRandomBehaviour&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.look.LookAtTarget&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.misc.Idle&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.misc.Panic&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.move.MoveToWalkTarget&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.target.SetRandomLookTarget&#10;import net.tslat.smartbrainlib.api.core.sensor.ExtendedSensor&#10;import net.tslat.smartbrainlib.api.core.sensor.vanilla.HurtBySensor&#10;import net.tslat.smartbrainlib.api.core.sensor.vanilla.NearbyPlayersSensor&#10;import net.tslat.smartbrainlib.api.core.sensor.vanilla.NearestItemSensor&#10;import net.tslat.smartbrainlib.util.BrainUtils&#10;import settingdust.calypsos_mobs.CalypsosMobsItems&#10;import settingdust.calypsos_mobs.WeightedMap&#10;import settingdust.calypsos_mobs.brain.behaviour.MoveToNearestVisibleWantedItem&#10;import software.bernie.geckolib.animatable.GeoEntity&#10;import software.bernie.geckolib.core.animatable.instance.AnimatableInstanceCache&#10;import software.bernie.geckolib.core.animation.AnimatableManager&#10;import software.bernie.geckolib.core.animation.Animation&#10;import software.bernie.geckolib.core.animation.AnimationController&#10;import software.bernie.geckolib.core.animation.RawAnimation&#10;import software.bernie.geckolib.core.`object`.PlayState&#10;import software.bernie.geckolib.util.GeckoLibUtil&#10;import kotlin.math.cos&#10;import kotlin.math.max&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;&#10;&#10;class FurnaceSprite(type: EntityType&lt;FurnaceSprite&gt;, level: Level) :&#10;    PathfinderMob(type, level),&#10;    GeoEntity,&#10;    SmartBrainOwner&lt;FurnaceSprite&gt;,&#10;    InventoryCarrier {&#10;    enum class HeatLevel(&#10;        val maxHeatTicks: Int,&#10;        val smeltingTicks: Int,&#10;        val workingParticle: (Level, FurnaceSprite) -&gt; Unit = { _, _ -&gt; },&#10;        val upgradingParticle: (Level, FurnaceSprite) -&gt; Unit = { _, _ -&gt; }&#10;    ) {&#10;        ZERO(0, 10 * 20),&#10;        ONE(&#10;            30 * 20,&#10;            10 * 20,&#10;            { level, entity -&gt; addWorkingParticle(level, entity, ParticleTypes.FLAME) }&#10;        ),&#10;        TWO(&#10;            60 * 20,&#10;            8 * 20,&#10;            { level, entity -&gt; addWorkingParticle(level, entity, ParticleTypes.FLAME, 2) },&#10;            { level, entity -&gt; addUpgradingParticle(level, entity, ParticleTypes.FLAME) }&#10;        ),&#10;        THREE(&#10;            90 * 20,&#10;            4 * 20,&#10;            { level, entity -&gt;&#10;                repeat(2) {&#10;                    addWorkingParticle(&#10;                        level,&#10;                        entity,&#10;                        if (entity.random.nextBoolean()) ParticleTypes.FLAME else ParticleTypes.SOUL_FIRE_FLAME&#10;                    )&#10;                }&#10;            },&#10;            { level, entity -&gt;&#10;                repeat(10 + entity.random.nextInt(4)) {&#10;                    addUpgradingParticle(&#10;                        level,&#10;                        entity,&#10;                        if (entity.random.nextBoolean()) ParticleTypes.FLAME else ParticleTypes.SOUL_FIRE_FLAME&#10;                    )&#10;                }&#10;            }&#10;        ),&#10;        FOUR(&#10;            160 * 20,&#10;            2 * 20,&#10;            { level, entity -&gt; addWorkingParticle(level, entity, ParticleTypes.SOUL_FIRE_FLAME, 2) },&#10;            { level, entity -&gt; addUpgradingParticle(level, entity, ParticleTypes.SOUL_FIRE_FLAME) }&#10;        );&#10;&#10;        companion object {&#10;            fun fromHeatTicks(heat: Int): HeatLevel {&#10;                return HeatLevel.entries.last { heat &gt;= it.maxHeatTicks }&#10;            }&#10;&#10;            private fun addWorkingParticle(&#10;                level: Level,&#10;                entity: FurnaceSprite,&#10;                particle: ParticleOptions,&#10;                count: Int = 1&#10;            ) {&#10;                repeat(count) {&#10;                    if (entity.random.nextDouble() &gt; 0.1) return@repeat&#10;                    val offsetX = (entity.random.nextDouble() - 0.5) * 1.2&#10;                    val offsetZ = (entity.random.nextDouble() - 0.5) * 1.2&#10;                    level.addParticle(&#10;                        particle,&#10;                        entity.x + offsetX,&#10;                        entity.y + 1.1 + (entity.random.nextDouble() - 0.5) * 0.2,&#10;                        entity.z + offsetZ,&#10;                        0.0, 0.0, 0.0&#10;                    )&#10;                }&#10;            }&#10;&#10;            private fun addUpgradingParticle(level: Level, entity: FurnaceSprite, particle: ParticleOptions) {&#10;                repeat(10 + entity.random.nextInt(4)) {&#10;                    val angle = entity.random.nextDouble() * 2 * Math.PI&#10;                    val distance = 1 + entity.random.nextDouble() * 0.4&#10;                    val offsetX = cos(angle) * distance&#10;                    val offsetZ = sin(angle) * distance&#10;                    val offsetY = 0.2 + entity.random.nextDouble() * 0.3&#10;&#10;                    val velocityX = offsetX * 0.1&#10;                    val velocityZ = offsetZ * 0.1&#10;                    val velocityY = 0.05 + entity.random.nextDouble() * 0.1&#10;&#10;                    level.addParticle(&#10;                        particle,&#10;                        entity.x + offsetX,&#10;                        entity.y + offsetY,&#10;                        entity.z + offsetZ,&#10;                        velocityX, velocityY, velocityZ&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        fun isAtLeast(level: HeatLevel) = this.ordinal &gt;= level.ordinal&#10;    }&#10;&#10;    companion object {&#10;        @JvmStatic&#10;        val INITIALIZED: EntityDataAccessor&lt;Boolean&gt; =&#10;            SynchedEntityData.defineId(FurnaceSprite::class.java, EntityDataSerializers.BOOLEAN)&#10;&#10;        @JvmStatic&#10;        val SLEEPY_DURATION: EntityDataAccessor&lt;Int&gt; =&#10;            SynchedEntityData.defineId(FurnaceSprite::class.java, EntityDataSerializers.INT)&#10;&#10;        @JvmStatic&#10;        val HEAT_LEVEL: EntityDataAccessor&lt;HeatLevel&gt; =&#10;            SynchedEntityData.defineId(FurnaceSprite::class.java, EntityDataSerializer.simpleEnum(HeatLevel::class.java))&#10;&#10;        @JvmStatic&#10;        val WORKING: EntityDataAccessor&lt;Boolean&gt; =&#10;            SynchedEntityData.defineId(FurnaceSprite::class.java, EntityDataSerializers.BOOLEAN)&#10;&#10;        private object Animations {&#10;            val IDLE = RawAnimation.begin().then(&quot;furnace_sprite.idle&quot;, Animation.LoopType.PLAY_ONCE)&#10;            val IDLE2 = RawAnimation.begin().then(&quot;furnace_sprite.idle2&quot;, Animation.LoopType.PLAY_ONCE)&#10;            val IDLE3 = RawAnimation.begin().then(&quot;furnace_sprite.idle3&quot;, Animation.LoopType.PLAY_ONCE)&#10;            val IDLE4 = RawAnimation.begin().then(&quot;furnace_sprite.idle4&quot;, Animation.LoopType.PLAY_ONCE)&#10;            val IDLE5 = RawAnimation.begin().then(&quot;furnace_sprite.idle5&quot;, Animation.LoopType.PLAY_ONCE)&#10;&#10;            val WEIGHTED_IDLE = WeightedMap(&#10;                mapOf(&#10;                    IDLE to 1.0,&#10;                    IDLE2 to 0.2,&#10;                    IDLE3 to 0.05,&#10;                    IDLE4 to 0.05,&#10;                    IDLE5 to 0.05&#10;                )&#10;            )&#10;&#10;            val WALK = RawAnimation.begin().thenPlay(&quot;furnace_sprite.walk&quot;)&#10;            val WAKEUP = RawAnimation.begin().thenPlay(&quot;furnace_sprite.wake_up&quot;)&#10;            val SLEEP = RawAnimation.begin().thenPlay(&quot;furnace_sprite.sleep&quot;).thenLoop(&quot;furnace_sprite.sleep_idle&quot;)&#10;            val ABSORB = RawAnimation.begin().thenPlay(&quot;furnace_sprite.absorb&quot;)&#10;            val SPIT = RawAnimation.begin().thenPlay(&quot;furnace_sprite.spit&quot;)&#10;            val SPIT2 = RawAnimation.begin().thenPlay(&quot;furnace_sprite.spit2&quot;)&#10;&#10;            val SPITS = arrayOf(&quot;Spit&quot;, &quot;Spit2&quot;)&#10;        }&#10;&#10;        const val SLEEP_THRESHOLD = 60 * 20&#10;    }&#10;&#10;    init {&#10;        setPersistenceRequired()&#10;        setCanPickUpLoot(true)&#10;    }&#10;&#10;    private val inventory = SimpleContainer(1)&#10;    private val testInventory = SimpleContainer(1)&#10;&#10;    private var targetItemEntity: ItemEntity? = null&#10;&#10;    override fun getInventory() = inventory&#10;&#10;    private val geoCache = GeckoLibUtil.createInstanceCache(this)&#10;    private var progress = 0.0&#10;&#10;    override fun getAnimatableInstanceCache(): AnimatableInstanceCache = geoCache&#10;&#10;    override fun registerControllers(registrar: AnimatableManager.ControllerRegistrar): Unit = registrar.run {&#10;        add(AnimationController(this@FurnaceSprite, 0) { state -&gt;&#10;            val moving = state.isMoving&#10;            val idling by lazy { state.controller.currentRawAnimation in Animations.WEIGHTED_IDLE.original.keys }&#10;            when {&#10;                entityData.get(SLEEPY_DURATION) &gt; SLEEP_THRESHOLD -&gt; state.setAndContinue(Animations.SLEEP)&#10;                !moving &amp;&amp; (state.controller.hasAnimationFinished() || !idling) -&gt;&#10;                    state.setAndContinue(Animations.WEIGHTED_IDLE.randomByWeight())&#10;&#10;                moving -&gt; state.setAndContinue(Animations.WALK)&#10;                else -&gt; PlayState.CONTINUE&#10;            }&#10;        })&#10;        add(&#10;            AnimationController(this@FurnaceSprite, &quot;ItemInteract&quot;) { PlayState.STOP }&#10;                .triggerableAnim(&quot;Absorb&quot;, Animations.ABSORB)&#10;                .triggerableAnim(&quot;Spit&quot;, Animations.SPIT)&#10;                .triggerableAnim(&quot;Spit2&quot;, Animations.SPIT2)&#10;        )&#10;        add(&#10;            AnimationController(this@FurnaceSprite, &quot;WakeUp&quot;) { PlayState.STOP }&#10;                .triggerableAnim(&quot;WakeUp&quot;, Animations.WAKEUP)&#10;        )&#10;    }&#10;&#10;    private fun tryWakeUp() {&#10;        if (entityData.get(SLEEPY_DURATION) &gt; SLEEP_THRESHOLD) {&#10;            triggerAnim(&quot;WakeUp&quot;, &quot;WakeUp&quot;)&#10;        }&#10;        entityData.set(SLEEPY_DURATION, 0)&#10;    }&#10;&#10;    private val recipeCheck = RecipeManager.createCheck(RecipeType.SMELTING)&#10;&#10;    override fun brainProvider() = SmartBrainProvider(this)&#10;&#10;    override fun customServerAiStep() {&#10;        tickBrain(this)&#10;    }&#10;&#10;    override fun getSensors(): List&lt;ExtendedSensor&lt;out FurnaceSprite&gt;&gt; = listOf(&#10;        NearbyPlayersSensor&lt;FurnaceSprite&gt;()&#10;            .setRadius(10.0, 4.0)&#10;            .setPredicate { player, entity -&gt;&#10;                !player.isSpectator &amp;&amp; entity.wantsToPickUp(player.mainHandItem)&#10;            }&#10;            .afterScanning { entity -&gt;&#10;                val player =&#10;                    BrainUtils.getMemory(entity, MemoryModuleType.NEAREST_VISIBLE_PLAYER)&#10;                val target = BrainUtils.getMemory(entity, MemoryModuleType.LOOK_TARGET)&#10;                if (target is EntityTracker &amp;&amp; target.entity is Player &amp;&amp; player == null) {&#10;                    BrainUtils.clearMemory(entity, MemoryModuleType.LOOK_TARGET)&#10;                } else if (player != null) {&#10;                    BrainUtils.setMemory(entity, MemoryModuleType.LOOK_TARGET, EntityTracker(player, false))&#10;                }&#10;            },&#10;        NearestItemSensor&lt;FurnaceSprite&gt;().setRadius(10.0, 4.0).setPredicate { item, entity -&gt;&#10;            item.owner != entity &amp;&amp; entity.wantsToPickUp(item.item) &amp;&amp; entity.hasLineOfSight(item)&#10;        },&#10;        HurtBySensor&lt;FurnaceSprite&gt;()&#10;    )&#10;&#10;    override fun getCoreTasks(): BrainActivityGroup&lt;out FurnaceSprite&gt; = BrainActivityGroup.coreTasks(&#10;        MoveToWalkTarget&lt;FurnaceSprite&gt;()&#10;    )&#10;&#10;    override fun getAdditionalTasks(): Map&lt;Activity, BrainActivityGroup&lt;out FurnaceSprite&gt;&gt; = mapOf(&#10;        Activity.PANIC to BrainActivityGroup&lt;FurnaceSprite&gt;(Activity.PANIC)&#10;            .behaviours(Panic&lt;FurnaceSprite&gt;().panicFor { _, _ -&gt; 10 }.setRadius(3.0))&#10;            .requireAndWipeMemoriesOnUse(MemoryModuleType.HURT_BY, MemoryModuleType.HURT_BY_ENTITY)&#10;    )&#10;&#10;    override fun getIdleTasks(): BrainActivityGroup&lt;out FurnaceSprite&gt; = BrainActivityGroup.idleTasks(&#10;        FirstApplicableBehaviour(&#10;            MoveToNearestVisibleWantedItem&lt;FurnaceSprite&gt; { _, _ -&gt; 1.25f }.startCondition { entity -&gt;&#10;                val itemEntity = BrainUtils.getMemory(entity, MemoryModuleType.NEAREST_VISIBLE_WANTED_ITEM)&#10;                    ?: return@startCondition false&#10;                val canMerge by lazy { ItemStack.isSameItemSameTags(entity.inventory.getItem(0), itemEntity.item) }&#10;                entity.tryWakeUp()&#10;                (entity.inventory.isEmpty || canMerge)&#10;                        &amp;&amp; (targetItemEntity == null || targetItemEntity!!.isRemoved&#10;                        || entity.distanceToSqr(targetItemEntity) &gt; entity.distanceTo(itemEntity))&#10;            }.cooldownFor { 20 },&#10;            LookAtTarget&lt;FurnaceSprite&gt;().runFor { 20 }.whenStarting { entity -&gt;&#10;                val target = BrainUtils.getMemory(entity, MemoryModuleType.LOOK_TARGET)&#10;                if (target !is EntityTracker) return@whenStarting&#10;                entity.tryWakeUp()&#10;                entity.lookAt(target.entity, 90F, 90F)&#10;            },&#10;            OneRandomBehaviour(&#10;                SetRandomLookTarget&lt;FurnaceSprite&gt;().startCondition { entity -&gt;&#10;                    entity.entityData.get(SLEEPY_DURATION) &lt; SLEEP_THRESHOLD&#10;                },&#10;                Idle&lt;FurnaceSprite&gt;().runFor { it.getRandom().nextIntBetweenInclusive(30, 60) }&#10;            )&#10;        )&#10;    )&#10;&#10;    override fun getActivityPriorities() = listOf(Activity.PANIC, Activity.IDLE)&#10;&#10;    override fun defineSynchedData() {&#10;        super.defineSynchedData()&#10;        entityData.define(HEAT_LEVEL, HeatLevel.ZERO)&#10;        entityData.define(SLEEPY_DURATION, 0)&#10;        entityData.define(INITIALIZED, false)&#10;        entityData.define(WORKING, false)&#10;    }&#10;&#10;    override fun canHoldItem(stack: ItemStack): Boolean {&#10;        testInventory.setItem(0, stack)&#10;        val recipe = recipeCheck.getRecipeFor(testInventory, level())&#10;        testInventory.clearContent()&#10;        return recipe.isPresent&#10;    }&#10;&#10;    override fun pickUpItem(itemEntity: ItemEntity) {&#10;        if (itemEntity.owner == this) return&#10;        triggerAnim(&quot;ItemInteract&quot;, &quot;Absorb&quot;)&#10;        InventoryCarrier.pickUpItem(this, this, itemEntity)&#10;        targetItemEntity = null&#10;    }&#10;&#10;    private fun dropAllItems() {&#10;        val forward = forward.scale(0.6)&#10;        val horizontalForward = Vec3(forward.x, 0.0, forward.z).normalize().scale(0.2).add(position())&#10;        this.inventory.removeAllItems()&#10;            .forEach { BehaviorUtils.throwItem(this, it, horizontalForward) }&#10;        triggerAnim(&quot;ItemInteract&quot;, Animations.SPITS[random.nextInt(Animations.SPITS.size - 1)])&#10;    }&#10;&#10;    override fun dropEquipment() {&#10;        super.dropEquipment()&#10;        dropAllItems()&#10;    }&#10;&#10;    override fun hurt(source: DamageSource, amount: Float): Boolean {&#10;        tryWakeUp()&#10;        dropAllItems()&#10;        return super.hurt(source, amount)&#10;    }&#10;&#10;    override fun mobInteract(player: Player, hand: InteractionHand): InteractionResult {&#10;        val itemInHand = player.getItemInHand(hand)&#10;        val burnTime by lazy { ForgeHooks.getBurnTime(itemInHand, RecipeType.SMELTING) }&#10;        return when {&#10;            itemInHand.isEmpty -&gt; {&#10;                player.setItemInHand(hand, inventory.getItem(0))&#10;                inventory.clearContent()&#10;                tryWakeUp()&#10;                InteractionResult.sidedSuccess(level().isClientSide)&#10;            }&#10;&#10;            burnTime &gt; 0 -&gt; {&#10;                entityData.set(HEAT, min(HeatLevel.entries.last().maxHeatTicks, entityData.get(HEAT) + burnTime))&#10;                itemInHand.shrink(1)&#10;                tryWakeUp()&#10;                InteractionResult.sidedSuccess(level().isClientSide)&#10;            }&#10;&#10;            else -&gt; InteractionResult.PASS&#10;        }&#10;    }&#10;&#10;    private var regenTimer = 0&#10;&#10;    override fun tick() {&#10;        super.tick()&#10;        if (!level().isClientSide) {&#10;            val prevHeat = entityData.get(HEAT)&#10;            val heat = if (inventory.isEmpty) {&#10;                if (prevHeat == HeatLevel.ZERO) HeatLevel.ZERO&#10;                else HeatLevel.entries[prevHeat.ordinal - 1]&#10;            } else {&#10;                if (prevHeat == HeatLevel.FOUR) HeatLevel.FOUR&#10;                max(0, prevHeat - 1)&#10;            entityData.set(HEAT, heat)&#10;                min(HeatLevel.entries.last().maxHeatTicks, prevHeat + 1)&#10;&#10;            if (heat == HeatLevel.ZERO &amp;&amp; ++regenTimer &gt;= 20) {&#10;                heal(1f)&#10;            } else {&#10;                regenTimer = 0&#10;            if (heat &gt; 0 &amp;&amp; ++regenTimer &gt;= 20) {&#10;&#10;            if (inventory.isEmpty) {&#10;                entityData.set(WORKING, false)&#10;                progress = 0.0&#10;                val sleepy = level().isNight || level().getRawBrightness(blockPosition(), 0) &lt; 8&#10;                if (sleepy) {&#10;                    entityData.set(SLEEPY_DURATION, entityData.get(SLEEPY_DURATION) + 1)&#10;                } else if (entityData.get(SLEEPY_DURATION) &gt; SLEEP_THRESHOLD) {&#10;                    tryWakeUp()&#10;                }&#10;                return&#10;            }&#10;&#10;            entityData.set(WORKING, true)&#10;&#10;            tryWakeUp()&#10;&#10;            progress += 1.0 / heat.smeltingTicks&#10;&#10;            if (progress &gt;= 1.0) {&#10;                val recipe = recipeCheck.getRecipeFor(inventory, level()).orElseThrow()&#10;            progress += 1.0 / currentHeatLevel.smeltingTicks&#10;                inventory.getItem(0).shrink(1)&#10;                triggerAnim(&quot;ItemInteract&quot;, Animations.SPITS[random.nextInt(Animations.SPITS.size - 1)])&#10;                val forward = forward.scale(0.6)&#10;                val horizontalForward = Vec3(forward.x, 0.0, forward.z).normalize().scale(0.2).add(position())&#10;                BehaviorUtils.throwItem(this, result, horizontalForward)&#10;                progress = 0.0&#10;            }&#10;        } else {&#10;            if (entityData.get(WORKING)) {&#10;                if (random.nextDouble() &lt; 0.1) {&#10;                    playSound(&#10;                        SoundEvents.FURNACE_FIRE_CRACKLE,&#10;                        1.0f,&#10;                        1.0f&#10;                    )&#10;                }&#10;            }&#10;&#10;            val heat = entityData.get(HEAT)&#10;            if (heat != HeatLevel.ZERO) {&#10;                heat.workingParticle(level(), this)&#10;            }&#10;        }&#10;            if (heat &gt; 0) {&#10;                val currentHeatLevel = HeatLevel.fromHeatTicks(heat)&#10;                currentHeatLevel.workingParticle(level(), this)&#10;    override fun getPickResult() = ItemStack(CalypsosMobsItems.FURNACE_SPRITE)&#10;&#10;    override fun getBoundingBoxForCulling(): AABB {&#10;        return super.getBoundingBoxForCulling().inflate(0.6)&#10;    }&#10;&#10;    override fun addAdditionalSaveData(compound: CompoundTag) {&#10;        super.addAdditionalSaveData(compound)&#10;        compound.putInt(&quot;HeatLevel&quot;, entityData.get(HEAT_LEVEL).ordinal)&#10;        compound.putBoolean(&quot;Initialized&quot;, entityData.get(INITIALIZED))&#10;        compound.putInt(&quot;SleepyDuration&quot;, entityData.get(SLEEPY_DURATION))&#10;        compound.putBoolean(&quot;Working&quot;, entityData.get(WORKING))&#10;    }&#10;&#10;    override fun readAdditionalSaveData(compound: CompoundTag) {&#10;        super.readAdditionalSaveData(compound)&#10;        entityData.set(HEAT_LEVEL, HeatLevel.entries[compound.getInt(&quot;HeatLevel&quot;)])&#10;        entityData.set(INITIALIZED, compound.getBoolean(&quot;Initialized&quot;))&#10;        entityData.set(SLEEPY_DURATION, compound.getInt(&quot;SleepyDuration&quot;))&#10;        entityData.set(WORKING, compound.getBoolean(&quot;Working&quot;))&#10;    }&#10;&#10;    override fun onAddedToWorld() {&#10;        super.onAddedToWorld()&#10;        if (level().isClientSide) return&#10;        if (!entityData.get(INITIALIZED)) {&#10;            entityData.set(INITIALIZED, true)&#10;            triggerAnim(&quot;WakeUp&quot;, &quot;WakeUp&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package settingdust.calypsos_mobs.entity&#10;&#10;import net.minecraft.core.particles.ParticleOptions&#10;import net.minecraft.core.particles.ParticleTypes&#10;import net.minecraft.nbt.CompoundTag&#10;import net.minecraft.network.syncher.EntityDataAccessor&#10;import net.minecraft.network.syncher.EntityDataSerializer&#10;import net.minecraft.network.syncher.EntityDataSerializers&#10;import net.minecraft.network.syncher.SynchedEntityData&#10;import net.minecraft.sounds.SoundEvents&#10;import net.minecraft.world.InteractionHand&#10;import net.minecraft.world.InteractionResult&#10;import net.minecraft.world.SimpleContainer&#10;import net.minecraft.world.damagesource.DamageSource&#10;import net.minecraft.world.entity.EntityType&#10;import net.minecraft.world.entity.PathfinderMob&#10;import net.minecraft.world.entity.ai.behavior.BehaviorUtils&#10;import net.minecraft.world.entity.ai.behavior.EntityTracker&#10;import net.minecraft.world.entity.ai.memory.MemoryModuleType&#10;import net.minecraft.world.entity.item.ItemEntity&#10;import net.minecraft.world.entity.npc.InventoryCarrier&#10;import net.minecraft.world.entity.player.Player&#10;import net.minecraft.world.entity.schedule.Activity&#10;import net.minecraft.world.item.ItemStack&#10;import net.minecraft.world.item.crafting.RecipeManager&#10;import net.minecraft.world.item.crafting.RecipeType&#10;import net.minecraft.world.level.Level&#10;import net.minecraft.world.phys.AABB&#10;import net.minecraft.world.phys.Vec3&#10;import net.minecraftforge.common.ForgeHooks&#10;import net.tslat.smartbrainlib.api.SmartBrainOwner&#10;import net.tslat.smartbrainlib.api.core.BrainActivityGroup&#10;import net.tslat.smartbrainlib.api.core.SmartBrainProvider&#10;import net.tslat.smartbrainlib.api.core.behaviour.FirstApplicableBehaviour&#10;import net.tslat.smartbrainlib.api.core.behaviour.OneRandomBehaviour&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.look.LookAtTarget&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.misc.Idle&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.misc.Panic&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.move.MoveToWalkTarget&#10;import net.tslat.smartbrainlib.api.core.behaviour.custom.target.SetRandomLookTarget&#10;import net.tslat.smartbrainlib.api.core.sensor.ExtendedSensor&#10;import net.tslat.smartbrainlib.api.core.sensor.vanilla.HurtBySensor&#10;import net.tslat.smartbrainlib.api.core.sensor.vanilla.NearbyPlayersSensor&#10;import net.tslat.smartbrainlib.api.core.sensor.vanilla.NearestItemSensor&#10;import net.tslat.smartbrainlib.util.BrainUtils&#10;import settingdust.calypsos_mobs.CalypsosMobsItems&#10;import settingdust.calypsos_mobs.WeightedMap&#10;import settingdust.calypsos_mobs.brain.behaviour.MoveToNearestVisibleWantedItem&#10;import software.bernie.geckolib.animatable.GeoEntity&#10;import software.bernie.geckolib.core.animatable.instance.AnimatableInstanceCache&#10;import software.bernie.geckolib.core.animation.AnimatableManager&#10;import software.bernie.geckolib.core.animation.Animation&#10;import software.bernie.geckolib.core.animation.AnimationController&#10;import software.bernie.geckolib.core.animation.RawAnimation&#10;import software.bernie.geckolib.core.`object`.PlayState&#10;import software.bernie.geckolib.util.GeckoLibUtil&#10;import kotlin.math.cos&#10;import kotlin.math.max&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;&#10;&#10;class FurnaceSprite(type: EntityType&lt;FurnaceSprite&gt;, level: Level) :&#10;    PathfinderMob(type, level),&#10;    GeoEntity,&#10;    SmartBrainOwner&lt;FurnaceSprite&gt;,&#10;    InventoryCarrier {&#10;    enum class HeatLevel(&#10;        val maxHeatTicks: Int,&#10;        val smeltingTicks: Int,&#10;        val workingParticle: (Level, FurnaceSprite) -&gt; Unit = { _, _ -&gt; },&#10;        val upgradingParticle: (Level, FurnaceSprite) -&gt; Unit = { _, _ -&gt; }&#10;    ) {&#10;        ZERO(0, 10 * 20),&#10;        ONE(&#10;            30 * 20,&#10;            10 * 20,&#10;            { level, entity -&gt; addWorkingParticle(level, entity, ParticleTypes.FLAME) }&#10;        ),&#10;        TWO(&#10;            60 * 20,&#10;            8 * 20,&#10;            { level, entity -&gt; addWorkingParticle(level, entity, ParticleTypes.FLAME, 2) },&#10;            { level, entity -&gt; addUpgradingParticle(level, entity, ParticleTypes.FLAME) }&#10;        ),&#10;        THREE(&#10;            90 * 20,&#10;            4 * 20,&#10;            { level, entity -&gt;&#10;                repeat(2) {&#10;                    addWorkingParticle(&#10;                        level,&#10;                        entity,&#10;                        if (entity.random.nextBoolean()) ParticleTypes.FLAME else ParticleTypes.SOUL_FIRE_FLAME&#10;                    )&#10;                }&#10;            },&#10;            { level, entity -&gt;&#10;                repeat(10 + entity.random.nextInt(4)) {&#10;                    addUpgradingParticle(&#10;                        level,&#10;                        entity,&#10;                        if (entity.random.nextBoolean()) ParticleTypes.FLAME else ParticleTypes.SOUL_FIRE_FLAME&#10;                    )&#10;                }&#10;            }&#10;        ),&#10;        FOUR(&#10;            160 * 20,&#10;            2 * 20,&#10;            { level, entity -&gt; addWorkingParticle(level, entity, ParticleTypes.SOUL_FIRE_FLAME, 2) },&#10;            { level, entity -&gt; addUpgradingParticle(level, entity, ParticleTypes.SOUL_FIRE_FLAME) }&#10;        );&#10;&#10;        companion object {&#10;            fun fromHeatTicks(heat: Int): HeatLevel {&#10;                return HeatLevel.entries.last { heat &gt;= it.maxHeatTicks }&#10;            }&#10;&#10;            private fun addWorkingParticle(&#10;                level: Level,&#10;                entity: FurnaceSprite,&#10;                particle: ParticleOptions,&#10;                count: Int = 1&#10;            ) {&#10;                repeat(count) {&#10;                    if (entity.random.nextDouble() &gt; 0.1) return@repeat&#10;                    val offsetX = (entity.random.nextDouble() - 0.5) * 1.2&#10;                    val offsetZ = (entity.random.nextDouble() - 0.5) * 1.2&#10;                    level.addParticle(&#10;                        particle,&#10;                        entity.x + offsetX,&#10;                        entity.y + 1.1 + (entity.random.nextDouble() - 0.5) * 0.2,&#10;                        entity.z + offsetZ,&#10;                        0.0, 0.0, 0.0&#10;                    )&#10;                }&#10;            }&#10;&#10;            private fun addUpgradingParticle(level: Level, entity: FurnaceSprite, particle: ParticleOptions) {&#10;                repeat(10 + entity.random.nextInt(4)) {&#10;                    val angle = entity.random.nextDouble() * 2 * Math.PI&#10;                    val distance = 1 + entity.random.nextDouble() * 0.4&#10;                    val offsetX = cos(angle) * distance&#10;                    val offsetZ = sin(angle) * distance&#10;                    val offsetY = 0.2 + entity.random.nextDouble() * 0.3&#10;&#10;                    val velocityX = offsetX * 0.1&#10;                    val velocityZ = offsetZ * 0.1&#10;                    val velocityY = 0.05 + entity.random.nextDouble() * 0.1&#10;&#10;                    level.addParticle(&#10;                        particle,&#10;                        entity.x + offsetX,&#10;                        entity.y + offsetY,&#10;                        entity.z + offsetZ,&#10;                        velocityX, velocityY, velocityZ&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        fun isAtLeast(level: HeatLevel) = this.ordinal &gt;= level.ordinal&#10;    }&#10;&#10;    companion object {&#10;        @JvmStatic&#10;        val INITIALIZED: EntityDataAccessor&lt;Boolean&gt; =&#10;            SynchedEntityData.defineId(FurnaceSprite::class.java, EntityDataSerializers.BOOLEAN)&#10;&#10;        @JvmStatic&#10;        val SLEEPY_DURATION: EntityDataAccessor&lt;Int&gt; =&#10;            SynchedEntityData.defineId(FurnaceSprite::class.java, EntityDataSerializers.INT)&#10;&#10;        @JvmStatic&#10;        val HEAT_LEVEL: EntityDataAccessor&lt;HeatLevel&gt; =&#10;            SynchedEntityData.defineId(FurnaceSprite::class.java, EntityDataSerializer.simpleEnum(HeatLevel::class.java))&#10;&#10;        @JvmStatic&#10;        val WORKING: EntityDataAccessor&lt;Boolean&gt; =&#10;            SynchedEntityData.defineId(FurnaceSprite::class.java, EntityDataSerializers.BOOLEAN)&#10;&#10;        private object Animations {&#10;            val IDLE = RawAnimation.begin().then(&quot;furnace_sprite.idle&quot;, Animation.LoopType.PLAY_ONCE)&#10;            val IDLE2 = RawAnimation.begin().then(&quot;furnace_sprite.idle2&quot;, Animation.LoopType.PLAY_ONCE)&#10;            val IDLE3 = RawAnimation.begin().then(&quot;furnace_sprite.idle3&quot;, Animation.LoopType.PLAY_ONCE)&#10;            val IDLE4 = RawAnimation.begin().then(&quot;furnace_sprite.idle4&quot;, Animation.LoopType.PLAY_ONCE)&#10;            val IDLE5 = RawAnimation.begin().then(&quot;furnace_sprite.idle5&quot;, Animation.LoopType.PLAY_ONCE)&#10;&#10;            val WEIGHTED_IDLE = WeightedMap(&#10;                mapOf(&#10;                    IDLE to 1.0,&#10;                    IDLE2 to 0.2,&#10;                    IDLE3 to 0.05,&#10;                    IDLE4 to 0.05,&#10;                    IDLE5 to 0.05&#10;                )&#10;            )&#10;&#10;            val WALK = RawAnimation.begin().thenPlay(&quot;furnace_sprite.walk&quot;)&#10;            val WAKEUP = RawAnimation.begin().thenPlay(&quot;furnace_sprite.wake_up&quot;)&#10;            val SLEEP = RawAnimation.begin().thenPlay(&quot;furnace_sprite.sleep&quot;).thenLoop(&quot;furnace_sprite.sleep_idle&quot;)&#10;            val ABSORB = RawAnimation.begin().thenPlay(&quot;furnace_sprite.absorb&quot;)&#10;            val SPIT = RawAnimation.begin().thenPlay(&quot;furnace_sprite.spit&quot;)&#10;            val SPIT2 = RawAnimation.begin().thenPlay(&quot;furnace_sprite.spit2&quot;)&#10;&#10;            val SPITS = arrayOf(&quot;Spit&quot;, &quot;Spit2&quot;)&#10;        }&#10;&#10;        const val SLEEP_THRESHOLD = 60 * 20&#10;    }&#10;&#10;    init {&#10;        setPersistenceRequired()&#10;        setCanPickUpLoot(true)&#10;    }&#10;&#10;    private val inventory = SimpleContainer(1)&#10;    private val testInventory = SimpleContainer(1)&#10;&#10;    private var targetItemEntity: ItemEntity? = null&#10;&#10;    override fun getInventory() = inventory&#10;&#10;    private val geoCache = GeckoLibUtil.createInstanceCache(this)&#10;    private var progress = 0.0&#10;&#10;    override fun getAnimatableInstanceCache(): AnimatableInstanceCache = geoCache&#10;&#10;    override fun registerControllers(registrar: AnimatableManager.ControllerRegistrar): Unit = registrar.run {&#10;        add(AnimationController(this@FurnaceSprite, 0) { state -&gt;&#10;            val moving = state.isMoving&#10;            val idling by lazy { state.controller.currentRawAnimation in Animations.WEIGHTED_IDLE.original.keys }&#10;            when {&#10;                entityData.get(SLEEPY_DURATION) &gt; SLEEP_THRESHOLD -&gt; state.setAndContinue(Animations.SLEEP)&#10;                !moving &amp;&amp; (state.controller.hasAnimationFinished() || !idling) -&gt;&#10;                    state.setAndContinue(Animations.WEIGHTED_IDLE.randomByWeight())&#10;&#10;                moving -&gt; state.setAndContinue(Animations.WALK)&#10;                else -&gt; PlayState.CONTINUE&#10;            }&#10;        })&#10;        add(&#10;            AnimationController(this@FurnaceSprite, &quot;ItemInteract&quot;) { PlayState.STOP }&#10;                .triggerableAnim(&quot;Absorb&quot;, Animations.ABSORB)&#10;                .triggerableAnim(&quot;Spit&quot;, Animations.SPIT)&#10;                .triggerableAnim(&quot;Spit2&quot;, Animations.SPIT2)&#10;        )&#10;        add(&#10;            AnimationController(this@FurnaceSprite, &quot;WakeUp&quot;) { PlayState.STOP }&#10;                .triggerableAnim(&quot;WakeUp&quot;, Animations.WAKEUP)&#10;        )&#10;    }&#10;&#10;    private fun tryWakeUp() {&#10;        if (entityData.get(SLEEPY_DURATION) &gt; SLEEP_THRESHOLD) {&#10;            triggerAnim(&quot;WakeUp&quot;, &quot;WakeUp&quot;)&#10;        }&#10;        entityData.set(SLEEPY_DURATION, 0)&#10;    }&#10;&#10;    private val recipeCheck = RecipeManager.createCheck(RecipeType.SMELTING)&#10;&#10;    override fun brainProvider() = SmartBrainProvider(this)&#10;&#10;    override fun customServerAiStep() {&#10;        tickBrain(this)&#10;    }&#10;&#10;    override fun getSensors(): List&lt;ExtendedSensor&lt;out FurnaceSprite&gt;&gt; = listOf(&#10;        NearbyPlayersSensor&lt;FurnaceSprite&gt;()&#10;            .setRadius(10.0, 4.0)&#10;            .setPredicate { player, entity -&gt;&#10;                !player.isSpectator &amp;&amp; entity.wantsToPickUp(player.mainHandItem)&#10;            }&#10;            .afterScanning { entity -&gt;&#10;                val player =&#10;                    BrainUtils.getMemory(entity, MemoryModuleType.NEAREST_VISIBLE_PLAYER)&#10;                val target = BrainUtils.getMemory(entity, MemoryModuleType.LOOK_TARGET)&#10;                if (target is EntityTracker &amp;&amp; target.entity is Player &amp;&amp; player == null) {&#10;                    BrainUtils.clearMemory(entity, MemoryModuleType.LOOK_TARGET)&#10;                } else if (player != null) {&#10;                    BrainUtils.setMemory(entity, MemoryModuleType.LOOK_TARGET, EntityTracker(player, false))&#10;                }&#10;            },&#10;        NearestItemSensor&lt;FurnaceSprite&gt;().setRadius(10.0, 4.0).setPredicate { item, entity -&gt;&#10;            item.owner != entity &amp;&amp; entity.wantsToPickUp(item.item) &amp;&amp; entity.hasLineOfSight(item)&#10;        },&#10;        HurtBySensor&lt;FurnaceSprite&gt;()&#10;    )&#10;&#10;    override fun getCoreTasks(): BrainActivityGroup&lt;out FurnaceSprite&gt; = BrainActivityGroup.coreTasks(&#10;        MoveToWalkTarget&lt;FurnaceSprite&gt;()&#10;    )&#10;&#10;    override fun getAdditionalTasks(): Map&lt;Activity, BrainActivityGroup&lt;out FurnaceSprite&gt;&gt; = mapOf(&#10;        Activity.PANIC to BrainActivityGroup&lt;FurnaceSprite&gt;(Activity.PANIC)&#10;            .behaviours(Panic&lt;FurnaceSprite&gt;().panicFor { _, _ -&gt; 10 }.setRadius(3.0))&#10;            .requireAndWipeMemoriesOnUse(MemoryModuleType.HURT_BY, MemoryModuleType.HURT_BY_ENTITY)&#10;    )&#10;&#10;    override fun getIdleTasks(): BrainActivityGroup&lt;out FurnaceSprite&gt; = BrainActivityGroup.idleTasks(&#10;        FirstApplicableBehaviour(&#10;            MoveToNearestVisibleWantedItem&lt;FurnaceSprite&gt; { _, _ -&gt; 1.25f }.startCondition { entity -&gt;&#10;                val itemEntity = BrainUtils.getMemory(entity, MemoryModuleType.NEAREST_VISIBLE_WANTED_ITEM)&#10;                    ?: return@startCondition false&#10;                val canMerge by lazy { ItemStack.isSameItemSameTags(entity.inventory.getItem(0), itemEntity.item) }&#10;                entity.tryWakeUp()&#10;                (entity.inventory.isEmpty || canMerge)&#10;                        &amp;&amp; (targetItemEntity == null || targetItemEntity!!.isRemoved&#10;                        || entity.distanceToSqr(targetItemEntity) &gt; entity.distanceTo(itemEntity))&#10;            }.cooldownFor { 20 },&#10;            LookAtTarget&lt;FurnaceSprite&gt;().runFor { 20 }.whenStarting { entity -&gt;&#10;                val target = BrainUtils.getMemory(entity, MemoryModuleType.LOOK_TARGET)&#10;                if (target !is EntityTracker) return@whenStarting&#10;                entity.tryWakeUp()&#10;                entity.lookAt(target.entity, 90F, 90F)&#10;            },&#10;            OneRandomBehaviour(&#10;                SetRandomLookTarget&lt;FurnaceSprite&gt;().startCondition { entity -&gt;&#10;                    entity.entityData.get(SLEEPY_DURATION) &lt; SLEEP_THRESHOLD&#10;                },&#10;                Idle&lt;FurnaceSprite&gt;().runFor { it.getRandom().nextIntBetweenInclusive(30, 60) }&#10;            )&#10;        )&#10;    )&#10;&#10;    override fun getActivityPriorities() = listOf(Activity.PANIC, Activity.IDLE)&#10;&#10;    override fun defineSynchedData() {&#10;        super.defineSynchedData()&#10;        entityData.define(HEAT_LEVEL, HeatLevel.ZERO)&#10;        entityData.define(SLEEPY_DURATION, 0)&#10;        entityData.define(INITIALIZED, false)&#10;        entityData.define(WORKING, false)&#10;    }&#10;&#10;    override fun canHoldItem(stack: ItemStack): Boolean {&#10;        testInventory.setItem(0, stack)&#10;        val recipe = recipeCheck.getRecipeFor(testInventory, level())&#10;        testInventory.clearContent()&#10;        return recipe.isPresent&#10;    }&#10;&#10;    override fun pickUpItem(itemEntity: ItemEntity) {&#10;        if (itemEntity.owner == this) return&#10;        triggerAnim(&quot;ItemInteract&quot;, &quot;Absorb&quot;)&#10;        InventoryCarrier.pickUpItem(this, this, itemEntity)&#10;        targetItemEntity = null&#10;    }&#10;&#10;    private fun dropAllItems() {&#10;        val forward = forward.scale(0.6)&#10;        val horizontalForward = Vec3(forward.x, 0.0, forward.z).normalize().scale(0.2).add(position())&#10;        this.inventory.removeAllItems()&#10;            .forEach { BehaviorUtils.throwItem(this, it, horizontalForward) }&#10;        triggerAnim(&quot;ItemInteract&quot;, Animations.SPITS[random.nextInt(Animations.SPITS.size - 1)])&#10;    }&#10;&#10;    override fun dropEquipment() {&#10;        super.dropEquipment()&#10;        dropAllItems()&#10;    }&#10;&#10;    override fun hurt(source: DamageSource, amount: Float): Boolean {&#10;        tryWakeUp()&#10;        dropAllItems()&#10;        return super.hurt(source, amount)&#10;    }&#10;&#10;    override fun mobInteract(player: Player, hand: InteractionHand): InteractionResult {&#10;        val itemInHand = player.getItemInHand(hand)&#10;        val burnTime by lazy { ForgeHooks.getBurnTime(itemInHand, RecipeType.SMELTING) }&#10;        return when {&#10;            itemInHand.isEmpty -&gt; {&#10;                player.setItemInHand(hand, inventory.getItem(0))&#10;                inventory.clearContent()&#10;                tryWakeUp()&#10;                InteractionResult.sidedSuccess(level().isClientSide)&#10;            }&#10;&#10;            burnTime &gt; 0 -&gt; {&#10;                entityData.set(HEAT, min(HeatLevel.entries.last().maxHeatTicks, entityData.get(HEAT) + burnTime))&#10;                itemInHand.shrink(1)&#10;                tryWakeUp()&#10;                InteractionResult.sidedSuccess(level().isClientSide)&#10;            }&#10;&#10;            else -&gt; InteractionResult.PASS&#10;        }&#10;    }&#10;&#10;    private var regenTimer = 0&#10;&#10;    override fun tick() {&#10;        super.tick()&#10;        if (!level().isClientSide) {&#10;            val prevHeat = entityData.get(HEAT)&#10;            val heat = if (inventory.isEmpty) {&#10;                if (prevHeat == HeatLevel.ZERO) HeatLevel.ZERO&#10;                else HeatLevel.entries[prevHeat.ordinal - 1]&#10;            } else {&#10;                if (prevHeat == HeatLevel.FOUR) HeatLevel.FOUR&#10;                max(0, prevHeat - 1)&#10;            entityData.set(HEAT, heat)&#10;                min(HeatLevel.entries.last().maxHeatTicks, prevHeat + 1)&#10;&#10;            if (heat == HeatLevel.ZERO &amp;&amp; ++regenTimer &gt;= 20) {&#10;                heal(1f)&#10;            } else {&#10;                regenTimer = 0&#10;            if (heat &gt; 0 &amp;&amp; ++regenTimer &gt;= 20) {&#10;&#10;            if (inventory.isEmpty) {&#10;                entityData.set(WORKING, false)&#10;                progress = 0.0&#10;                val sleepy = level().isNight || level().getRawBrightness(blockPosition(), 0) &lt; 8&#10;                if (sleepy) {&#10;                    entityData.set(SLEEPY_DURATION, entityData.get(SLEEPY_DURATION) + 1)&#10;                } else if (entityData.get(SLEEPY_DURATION) &gt; SLEEP_THRESHOLD) {&#10;                    tryWakeUp()&#10;                }&#10;                return&#10;            }&#10;&#10;            entityData.set(WORKING, true)&#10;&#10;            tryWakeUp()&#10;&#10;            progress += 1.0 / heat.smeltingTicks&#10;&#10;            if (progress &gt;= 1.0) {&#10;                val recipe = recipeCheck.getRecipeFor(inventory, level()).orElseThrow()&#10;            progress += 1.0 / currentHeatLevel.smeltingTicks&#10;                inventory.getItem(0).shrink(1)&#10;                triggerAnim(&quot;ItemInteract&quot;, Animations.SPITS[random.nextInt(Animations.SPITS.size - 1)])&#10;                val forward = forward.scale(0.6)&#10;                val horizontalForward = Vec3(forward.x, 0.0, forward.z).normalize().scale(0.2).add(position())&#10;                BehaviorUtils.throwItem(this, result, horizontalForward)&#10;                progress = 0.0&#10;            }&#10;        } else {&#10;            if (entityData.get(WORKING)) {&#10;                if (random.nextDouble() &lt; 0.1) {&#10;                    playSound(&#10;                        SoundEvents.FURNACE_FIRE_CRACKLE,&#10;                        1.0f,&#10;                        1.0f&#10;                    )&#10;                }&#10;            }&#10;&#10;            val heat = entityData.get(HEAT)&#10;            if (heat != HeatLevel.ZERO) {&#10;                heat.workingParticle(level(), this)&#10;            }&#10;        }&#10;            if (heat &gt; 0) {&#10;                val currentHeatLevel = HeatLevel.fromHeatTicks(heat)&#10;                currentHeatLevel.workingParticle(level(), this)&#10;    override fun getPickResult() = ItemStack(CalypsosMobsItems.FURNACE_SPRITE)&#10;&#10;    override fun getBoundingBoxForCulling(): AABB {&#10;        return super.getBoundingBoxForCulling().inflate(0.6)&#10;    }&#10;&#10;    override fun addAdditionalSaveData(compound: CompoundTag) {&#10;        super.addAdditionalSaveData(compound)&#10;        compound.putInt(&quot;HeatLevel&quot;, entityData.get(HEAT_LEVEL).ordinal)&#10;        compound.putBoolean(&quot;Initialized&quot;, entityData.get(INITIALIZED))&#10;        compound.putInt(&quot;SleepyDuration&quot;, entityData.get(SLEEPY_DURATION))&#10;        compound.putBoolean(&quot;Working&quot;, entityData.get(WORKING))&#10;    }&#10;&#10;    override fun readAdditionalSaveData(compound: CompoundTag) {&#10;        super.readAdditionalSaveData(compound)&#10;        entityData.set(HEAT_LEVEL, HeatLevel.entries[compound.getInt(&quot;HeatLevel&quot;)])&#10;        entityData.set(INITIALIZED, compound.getBoolean(&quot;Initialized&quot;))&#10;        entityData.set(SLEEPY_DURATION, compound.getInt(&quot;SleepyDuration&quot;))&#10;        entityData.set(WORKING, compound.getBoolean(&quot;Working&quot;))&#10;    }&#10;&#10;    override fun onAddedToWorld() {&#10;        super.onAddedToWorld()&#10;        if (level().isClientSide) return&#10;        if (!entityData.get(INITIALIZED)) {&#10;            entityData.set(INITIALIZED, true)&#10;            triggerAnim(&quot;WakeUp&quot;, &quot;WakeUp&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>